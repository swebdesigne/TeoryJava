## Collections Lite

#### part 2. [Collections Pro](CollectionsPro.md#collections-pro)

[1. Что такое коллекция?](#1-Что-такое-коллекция)

[2. Назовите преимущества использования коллекций?](#2-Назовите-преимущества-использования-коллекций)

[3. Какие данные могут хранить коллекции?](#3-Какие-данные-могут-хранить-коллекции)

[4. Какие есть типы коллекций? Как они характеризуются?](#4-Какие-есть-типы-коллекций-Как-они-характеризуются)

[5. Назовите основные реализации List, Set, Map?](#5-Назовите-основные-реализации-List,-Set,-Map)

[6. В чём отличие ArrayList от LinkedList?](#6-В-чём-отличие-ArrayList-от-LinkedList)

[7. В чём отличие HashSet от TreeSet?](#7-В-чём-отличие-HashSet-от-TreeSet)

[8. В чём отличие Set от Map?](#8-В-чём-отличие-Set-от-Map)

[9. Как задается порядок следования объектов в коллекции? Как отсортировать коллекцию?](#9-Как-задается-порядок-следования-объектов-в-коллекции-Как-отсортировать-коллекцию)

[10. Чем отличается Comparable от Comparator?](#10-Чем-отличается-Comparable-от-Comparator)

[11. Что такое сортировка по принципу Natural Order?](#11-Что-такое-сортировка-по-принципу-Natural-Order)

[12. Что такое equals и hashcode?](#12-Что-такое-equals-и-hashcode)

[13. Какие есть способы перебора всех элементов List?](#13-Какие-есть-способы-перебора-всех-элементов-List)

[14. Как реализован цикл foreach?](#14-Как-реализован-цикл-foreach)

[15. В чем разница между Iterator и ListIterator?](#15-В-чем-разница-между-Iterator-и-ListIterator)

[16. Как происходит удаление элементов из ArrayList?](#16-Как-происходит-удаление-элементов-из-ArrayList)

[17. Как происходит удаление элементов из LinkedList?](#17-Как-происходит-удаление-элементов-из-LinkedList)

[18. Расскажите иерархию интерфейсов Collections framework?](#18-Расскажите-иерархию-интерфейсов-Collections-framework)

[19. Назовите основные методы интерфейса Collections?](#19-Назовите-основные-методы-интерфейса-Collections)

[20. Может ли null использоваться в качестве ключа в Map?](#20-Может-ли-null-использоваться-в-качестве-ключа-в-Map)

[21. Может ли Set содержать null?](#21-Может-ли-Set-содержать-null)

[22. Как преобразовать массив строк в ArrayList?](#22-Как-преобразовать-массив-строк-в-ArrayList)

[23. Как отсортировать список в обратном порядке?](#23-Как-отсортировать-список-в-обратном-порядке)

[24. Какие реализации SortedSet вы знаете и в чем их особенность?](#24-Какие-реализации-SortedSet-вы-знаете-и-в-чем-их-особенность)

[25. В каких случаях разумно использовать массив, а не ArrayList?](#25-В-каких-случаях-разумно-использовать-массив-а-не-ArrayList)

[26. Какие коллекции синхронизированы?](#26-Какие-коллекции-синхронизированы)

## 1. Что такое коллекция?

**Коллекции** - это хранилища, поддерживающие различные способы накопения и упорядочивания объектов с целью обеспечения 
эффективного доступа к ним.

Они представляют собой реализации абстрактных структур данных, поддерживающих различные способы хранения данных, а также
операции добавления, удаления и изменения элементов. Т.е. это набор интерфейсов и реализующих их классов.

[к оглавлению](#collections-lite)

## 2. Назовите преимущества использования коллекций?

+ отсутствует необходимость следить за размерами коллекции (в отличае от массива);

+ позволяют сократить количество кода и требуют меньше усилий для реализации, т.к. в коллекциях реализовано 
много методов по добавлению, удалению, сортировке элементов и т.п.;

+ если правильно подобрать коллекцию, то можно увеличить производительность программы;

+ упрощают взаимодействие разных частей программы, т.к. являются универсальным способом хранения и передачи данных.

[к оглавлению](#collections-lite)

## 3. Какие данные могут хранить коллекции?

Коллекции могут хранить любые ссылочные типы данных.

[к оглавлению](#collections-lite)

## 4. Какие есть типы коллекций Как они характеризуются?

+ **Set** - множество неповторяющихся элементов (Здесь могут храниться только уникальные значения, нет дубликатов)

+ **Queue** (Deque) - очередь (FIFO первый вошел, первый вышел). реализует LinkedList

+ **List** - упорядоченный список (В какой последовательности данные положили, в такой они и хранятся.
Допускаются дубликаты.)

+ **Map** - карта, ассоциативный массив (Значения хранятся в виде пар ключ=значение. Каждому элементу из множества
ключей соответствует множество значений. Ключи уникальные. По ключу получаем значение. У мапы нет итератора. 
Map не наследуется от Collection.) 

Справочник по Java Collections Framework https://habr.com/ru/post/237043/

[к оглавлению](#collections-lite)

## 5. Назовите основные реализации List, Set, Map?

+ **List:** 
+ 
+ ArrayList - автоматически расширяемый массив. Вы можете работать с массивом, но при этом не используются квадратные скобки.

Массивы имеют фиксированную длину, и после того как массив создан, он не может расти или уменьшаться. ArrayList может менять свой размер во время исполнения программы, при этом не обязательно указывать размерность при создании объекта. Кроме того, вы без проблем можете вставить новый элемент в середину коллекции. А также спокойно удалить элемент из любого места. Элементы ArrayList могут быть абсолютно любых типов в том числе и null. Это удобно, когда вы не знаете точного размера массива. Для сравнения - гостиница для котов имеет фиксированное число номеров, массив использовать можно. Вы владелец преуспевающей компании и число наёмных работников постоянно увеличивается, обычный массив создавать для учёта сотрудников нецелесообразно. В этом случае удобнее работать со списочным массивом. Иногда говорят, что ArrayList - это массив на стероидах (продвинутый).

Работать с ArrayList просто: создайте нужный объект, вставьте объект методом add(), обращайтесь к нему методом get(), используйте индексирование так же, как для массивов, но без квадратных скобок. ArrayList также содержит метод size(), который возвращает текущее количество элементов в массиве (напомню, что в обычном массиве используется свойство length).

http://developer.alexanderklimov.ru/android/java/arraylist.php

+ LinkedList - Класс LinkedList имеет больше операций, чем ArrayList, а значит более сложный и требующий больше памяти. Класс представляет структуру данных связного списка и реализует интерфейсы List, Dequeue, Queue.

LinkedList позволяет хранить любые объекты, в том числе null и повторяющиеся.

Операции вставки и удаления в середине списка работают у него эффективнее. Но хуже обстоит дело с операциями произвольного доступа. В зависимости от вашей задачи и будет обусловлен выбор - ArrayList или LinkedList. Принцип работы сильно отличается. Тут уже не используется массив, а набор данных с двумя указателями на следующий и предыдущий объект. Вам не нужно думать о них, всё происходит под капотом.

Для добавления элемента в конец списка используется метод add(), для удаления используется метод remove().

http://developer.alexanderklimov.ru/android/java/linkedlist.php

+ **Set:** 

+ HashSet -Название Hash... происходит от понятия хэш-функция. Хэш-функция — это функция, сужающая множество значений объекта до некоторого подмножества целых чисел. Класс Object имеет метод hashCode(), который используется классом HashSet для эффективного размещения объектов, заносимых в коллекцию. В классах объектов, заносимых в HashSet, этот метод должен быть переопределен (override).

+ LinkedHashSat - это упорядоченная версия HashSet, которая поддерживает двусвязный список для всех элементов. Когда необходимо поддерживать порядок итераций, используется этот класс. При переборе HashSet порядок непредсказуем, а LinkedHashSet позволяет перебирать элементы в том порядке, в котором они были вставлены. При циклическом переходе по LinkedHashSet с использованием итератора элементы будут возвращены в том порядке, в котором они были вставлены.
+ Класс LinkedHashSet расширяет класс HashSet, не добавляя никаких новых методов. Класс поддерживает связный список элементов набора в том порядке, в котором они вставлялись. Это позволяет организовать упорядоченную итерацию вставки в набор.

+ TreeSet - переделанный пример для вывода случайных чисел в отсортированном порядке. HashSet не может гарантировать, что данные будут отсортированы, так как работает по другому алгоритму. Если сортировка для вас важна, то используйте TreeSet.

HashSet, TreeSet и LinkedHashSet относятся к семейству Set. В множествах Set каждый элемент хранится только в одном экземпляре, а разные реализации Set используют разный порядок хранения элементов. В HashSet порядок элементов определяется по сложному алгоритму. Если порядок хранения для вас важен, используйте контейнер TreeSet, в котором объекты хранятся отсортированными по возрастанию в порядке сравнения или LinkedHashSet с хранением элементов в порядке добавления.

Множества часто используются для проверки принадлежности, чтобы вы могли легко проверить, принадлежит ли объект заданному множеству, поэтому на практике обычно выбирается реализация HashSet, оптимизированная для быстрого поиска.

http://developer.alexanderklimov.ru/android/java/set.php

+ **Map:**

+   HashMap - использует хеш-таблицу для хранения карточки, обеспечивая быстрое время выполнения запросов get() и put() при больших наборах. Класс реализует интерфейс Map (хранение данных в виде пар ключ/значение). Ключи и значения могут быть любых типов, в том числе и null. При этом все ключи обязательно должны быть уникальны, а значения могут повторяться. Данная реализация не гарантирует порядка элементов.

http://developer.alexanderklimov.ru/android/java/hashmap.php
 
+   LinkedHashMap - отображение с запоминанием порядка, в котором добавлялись элементы, разрешает перебор в порядке вставки.

http://developer.alexanderklimov.ru/android/java/linkedhashmap.php

+   TreeMap - Ключи упорядочены, поэтому если вам нужно перебирать ключи в отсортированном порядке, вы можете. Это означает, что ключи должны реализовывать интерфейс Comparable. TreeMap реализован красно-черным деревом.

[к оглавлению](#collections-lite)

## 6. В чём отличие ArrayList от LinkedList?

**ArrayList - основан на динамическом массиве**, хранит свои элементы в массиве. 
(используют, если элементы чаще читаются, чем добавляются)

**+** Быстрая навигация по коллекции - осуществляется быстрый поиск элементов;

**+** меньше расходует памяти на хранение элементов;

**-** увеличение `ArrayList` происходит медленно;

**-** при вставке или удалении элемента в середину или в начало, приходится переписывать все элементы;

**LinkedList - двунаправленный список (цепочка)**, хранит элементы в объектах `Node<E>`, у которых есть ссылки на 
предыдущий и следующий элементы (используют, если элементы чаще добавляются, чем читаются) 

**+** быстрая вставка и удаление в середину списка (переписать `next` и `previous` и всё);

**-** долгий поиск в середине (нужно перебрать все элементы);

Очевидно, что плюсы одного являются минусами второго.
В среднем, сложности одинаковые, но все же `ArrayList` предпочтительнее использовать. 
`LinkedList` рекомендуется использовать, только когда преобладает удаление или вставка в начало или конец списка.

[к оглавлению](#collections-lite)

## 7. В чём отличие HashSet от TreeSet?

**Set** - множество неповторяющихся элементов.

**HashSet** хранит данные в произвольном порядке (хранит свои значения как ключи `HashMap`).

**TreeSet** хранит данные в отсортированном виде (в основе реализации бинарное красно-черное дерево).

[к оглавлению](#collections-lite)

## 8. В чём отличие Set от Map?

сет это список ключей от мапы.

[к оглавлению](#Collections-Lite)

## 9. Как задается порядок следования объектов в коллекции Как отсортировать коллекцию?

Порядок задается либо естественным следованием элементов (natural order), 
либо объектом, реализующим интерфейс сравнения `Comparator`.

Можно отсортировать с помощью интерфейса `Comparable` или интерфейса `Comparator`:
 
+ Если объекты коллекции поддерживают интерфейс `Comparable`, то через `Collections.sort(collection)`; 

+ Если нет, то у коллекции вызвать метод `sort()` и передать ему `Comparator` в качестве аргумента `collection.sort(new MyComparator())`.
Либо использовать метод `Collections.sort(collection, new MyComparator())`.

[к оглавлению](#collections-lite)

## 10. Чем отличается Comparable от Comparator?

**Comparable** - используется только для сравнения объектов класса, в котором данный интерфейс реализован. 
Т.е. интерфейс `Comparable` определяет логику сравнения объектов определенного ссылочного типа внутри своей 
реализации (по правилам разработчика). 
`Collections.sort(collection);`

**Comparator** - представляет отдельную реализацию и ее можно использовать многократно и с различными классами. 
Т.е. интерфейс `Comparator` позволяет создавать объекты, которые будут управлять процессом сравнения: 
1. при сортировках в методах `Collections.sort(collection, new MyComparator())`, `Arrays.sort(array, new MyComparator())` 
или `collection.sort(new MyComparator())`
2. при управлении порядком в отсортированных множествах `TreeSet` или отсортированных картах `TreeMap`,
 например `new TreeSet<T> (new MyComparator())`.

**Разница:**

+ `Comparable` определяет логику сравнения объектов определенного ссылочного типа внутри своей реализации 
и, если нет доступа к исходникам, ее невозможно изменить. 

+ `Comparator` позволает определить логику сравнения объектов определенного ссылочного типа вне реализации 
этого типа и эту логику можно в любой момент подменить.

*`Comparable` используется для `natural ordering`, а `Comparator` для `total ordering`.*

**Примеры:**

http://java-online.ru/blog-comparator.xhtml

https://netjs.blogspot.com/2015/10/difference-between-comparable-and-comparator-java.html

https://www.programcreek.com/2011/12/examples-to-demonstrate-comparable-vs-comparator-in-java/

[к оглавлению](#collections-lite)

## 11. Что такое сортировка по принципу Natural Order?

Некоторые классы из коробки реализуют естественный порядок `natural order` для сортировки:

+ строки - лексикографический (по алфавиту),
+ числа - числовой, знаковый или без (больше меньше),
+ дата - хронологичский (по датам),
+ файл - лексикографический по имени пути
+ boolean - false < true

Остальные классы нужно руками делать `Comparable` или `Comparator`.

[к оглавлению](#collections-lite)

## 12. Что такое equals и hashcode?

Методы, необходимые для определения равенства объектов. 

`hashcode` возвращает число, являющееся уникальным идентификатором объекта. 
Это алгоритм, который позволяет множество значений объектов сузить до какого-то натурального количества.
 
`equals` сравнивает объекты по значению их полей. 

Объекты всех коллекций в названии которых есть *Hash...* должны иметь `hashcode` и `equals`.

[к оглавлению](#collections-lite)

## 13. Какие есть способы перебора всех элементов List?

Есть список стран, его нужно перебрать
```java
List<String> countries = Arrays.asList("Russia", "Panama", "Australia");
```
+ **циклы** `for`, `while`, `foreach`

```java
for (int i = 0; i < countries.size(); i++) {
    System.out.println(countries.get(i));
}
```

```java
int i = 0;
while (i < countries.size()){
    System.out.println(countries.get(i++));
}
```

```java
for (String country : countries) {
    System.out.println(country);
}    
```

+ **итераторы** `Iterator`, `ListIterator`
```java
Iterator<String> countriesIterator = countries.iterator();
while(countriesIterator.hasNext()) {
    System.out.println(countriesIterator.next());
}
```

```java
ListIterator<String> listIterator = countries.listIterator();
//в прямом порядке
while(listIterator.hasNext()) {
    System.out.println(listIterator.next());
}
//в обратном порядке
while(listIterator.hasPrevious()) {
    System.out.println(listIterator.previous());
}    
```
Если вызвать метод `next()` итератора, указывающего на последний элемент в коллекции, 
то возникнет исключение `NoSuchElementException`. Следует это помнить и использовать метод `hasNext()` перед вызовом `next()`.

+ **функция `forEach()`** 
    
    + **`Iterable.forEach()`** можно использовать для итерации по элементам списка начиная с Java 8. 
Этот метод определен в интерфейсе Iterable и может принимать лямбда-выражения в качестве параметра.
    ```java
    countries.forEach(System.out::println);
    ```
    
    + **`Stream.forEach()`** Мы также можем преобразовать коллекцию значений в поток и получить доступ 
    к таким операциям, как `forEach()`, `map()`, или `filter()`.
    ```java
    countries.stream().forEach(
        (c) -> System.out.println(c)
    );
    ```
    
https://www.codeflow.site/ru/article/java-iterate-list    

[к оглавлению](#collections-lite)

## 14. Как реализован цикл foreach?

`foreach` реализован на основе `Iterator`, т.е. он работает для классов, реализующих интерфейс `Iterable`.

Метод forEach() выполняет заданное действие для каждого элемента Iterable до тех пор, пока все элементы не будут обработаны или действие не вызовет исключение.

(И наоборот, если коллекция `extends` от `Iterable`, то мы можем перебирать элементы этой коллекции с помощью `foreach`)

[к оглавлению](#collections-lite)

## 15. В чем разница между Iterator и ListIterator?

`ListIterator` расширяет `Iterator`, отличия следующие:

+ `Iterator` может использоваться для перебора элементов коллекций `Set`, `List` и `Map`. 
`ListIterator` может быть использован только для перебора элементов коллекции `List`

+ `Iterator` позволяет перебирать элементы только в одном направлении, при помощи метода `next()`. 
`ListIterator` позволяет перебирать список в обоих направлениях, при помощи методов `next()` и `previous()`.

+ `ListIterator` позволяет модифицировать список, добавляя/заменяя/удаляя элементы с помощью методов `add()`, `set()`
`remove()`. Iterator не поддерживает данного функционала.

[к оглавлению](#collections-lite)

## 16. Как происходит удаление элементов из ArrayList?

Находится заданный элемент. 
Далее сдвигаются влево на один элемент все последующие (с большим индексом) элементы, а значение `size` уменьшается на 1.

Непосредственно под капотом: 
```java
System.arraycopy(es, i + 1, es, i, newSize - i)
es[size = newSize] = null;
```

[к оглавлению](#collections-lite)

## 17. Как происходит удаление элементов из LinkedList?

Заменяются ссылки `previous` и `next` у соседних элементов.

[к оглавлению](#collections-lite)

## 18. Расскажите иерархию интерфейсов Collections framework?

+ interface **`Collections`** extends **`Iterable`**.
    + interface `Set` (коллекция без дублирования)
        + `HashSet` базирующаяся на `HashMap` В качестве ключа используется добавляемый элемент, 
        а в качестве значения — объект-пустышка (new Object())
        + `LinkedHashSet` в основе лежит `LinkedHashMap`
    + interface `SortedSet` Методы: `first()`, `last()`
        + `TreeSet` (отсортированный список) содержит в себе объект `NavigableMap`.
    + interface `Queue` очередь Методы: `offer()`, `element()`, `peek()`, `poll()`, `remove()`.
    + interface `Deque` двусторонняя очередь `addFirst()`, `addLast()`, `getFist()`, `getLast()`, 
    (`push()`, `pop()` -> использовать как стек)
    + interface `List` упорядоченная коллекция (сохраняет последовательность элементов. можно получить по индексу, можно 
    повторяющиеся, можно по значению первый найденный)
    + `Vector` @deprecated реализация динамического массива объектов. Позволяет хранить любые данные, включая `null` 
    в качестве элемента
        + `Stack` - данная коллекция является расширением коллекции `Vector`. реализация стека `LIFO`.
        + `ArrayList` динамический массив, можно хранить `null`
        + `LinkedList` связный список (implementation `List` & `Deque`)
+ interface **`Map`** (нет итератора, нельзя перебирать в цикле. Можно получить представление в виде коллекции для перебора) 
`get()`, `put()`, `entrySet()`, `keySet()`, `values()`.
    + interface `SortedMap` (по порядку нарастания ключей)
    + interface `NavigableMap`
        + `TreeMap` реализация `Map` основанная на красно-чёрных деревьях (отсортированная по умолчанию `natural odering`, 
        можно задать свой компаратор)
    + `AbstractMap`
    + `HashMap` позволяет использовать `null` как в качестве ключа, так и значения
        + LinkedHashMap  это упорядоченная реализация хэш-таблицы. Аналогично `LinkedList`
    + `WeekHashMap` - реализация хэш-таблицы, которая организована с использованием weak references. 
Другими словами, `Garbage Collector` автоматически удалит элемент из коллекции при следующей сборке мусора, если на ключ 
этого элеметна нет жёстких ссылок

Справочник по Java Collections Framework https://habr.com/ru/post/237043/

[к оглавлению](#Collections-Lite)

## 19. Назовите основные методы интерфейса Collections?

Основные:
+ `int size()` - узнать размер
+ `boolean isEmpty()` - проверить на пустоту
+ `boolean contains(Object o)` - проверить наличие
+ `Iterator<E> iterator()` - итерироваться
+ `Object[] toArray()` - получить как массив
+ `boolean add(E e)` - добавить
+ `boolean remove(Object o)` - удалить
+ `void clear()` - очистить

Остальные:
+ `boolean containsAll(Collection<?> c)` - проверить, содержит ли все элементы из другого списка
+ `boolean addAll(Collection<? extends E> c)` - добавить все из одного в другой
+ `boolean removeAll(Collection<?> c)` - удалить все элементы из другого
+ `boolean retainAll(Collection<?> c)` - оставить только общие
+ `boolean equals(Object o)` - проверить на равенсто
+ `int hashCode()` - тоже проверить на равенство

[к оглавлению](#Collections-Lite)

## 20. Может ли null использоваться в качестве ключа в Map?

`HashMap` оперирует с `null`-ключом без каких-либо проблем. Его `hash` всегда равен `0`. 

В пустой `TreeMap` можно положить единственный `null`-ключ, 
все остальные операции (кроме `size()` и `clear()`, кстати) после этого не работают. 

В непустой `TreeMap` положить `null`-ключ нельзя из-за обязательного вызова `compareTo()`.

[к оглавлению](#Collections-Lite)

## 21. Может ли Set содержать null?

для `HashSet` работает. `TreeSet` — только для первого элемента.

[к оглавлению](#Collections-Lite)

## 22. Как преобразовать массив строк в ArrayList?

```java
Arrays.asList(words)
```

[к оглавлению](#Collections-Lite)

## 23. Как отсортировать список в обратном порядке?

```java
List reversedList = Collections.reverse(list)
```

[к оглавлению](#Collections-Lite)

## 24. Какие реализации SortedSet вы знаете и в чем их особенность?

`TreeSet` - в основе лежит красно-черное дерево, которое умеет само себя балансировать.

`TreeSet` все равно в каком порядке вы добавляете в него элементы, преимущества этой структуры данных будут сохраняться.

[к оглавлению](#Collections-Lite)

## 25. В каких случаях разумно использовать массив, а не ArrayList?

Рекомендация от Oracle: используйте `ArrayList` вместо массивов. 

Если ответить на этот вопрос нужно по-другому, то можно сказать следующее: 
Массивы могут быть быстрее и кушать меньше памяти. 
Списки теряют в производительности из-за возможности автоматического увеличения размера и сопутствующих проверок.

[к оглавлению](#Collections-Lite)

## 26. Какие коллекции синхронизированы?

Для этого используется пакет `Concurrent`. А также `@Deprecated` `HashTable`, `Vector`.

Получение синхронизированной коллекции из не синхронизированной:
```java
Collections.synchronizedList(list);
Collections.synchronizedSet(set);
Collections.synchronizedMap(map);
```

Получение коллекции только для чтения:
```java
Collections.unmodifiableList(list);
Collections.unmodifiableSet(set);
Collections.unmodifiableMap(map);
```

[к оглавлению](#Collections-Lite)
